"""## Задача 3. Логирование
### Что нужно сделать
Реализуйте декоратор `logging`, который будет отвечать за логирование функций. На экран выводится название функции и её документация. Если во время выполнения декорируемой функции возникла ошибка, то в файл `function_errors.log` записываются названия функции и ошибки. 

Также постарайтесь сделать так, чтобы программа не завершалась после обнаружения первой же ошибки, а обрабатывала все декорируемые функции и сразу записывала все ошибки в файл.

Дополнительно: запишите дату и время возникновения ошибки, используя модуль `datetime`.
### Что оценивается
- Результат вычислений корректен.
- Сообщения о процессе получения результата осмыслены и понятны для пользователя.
- Переменные, функции и собственные методы классов имеют значащие имена (не `a`, `b`, `c`, `d`).
- Классы и методы/функции имеют прописанную документацию.
- Есть аннотация типов для методов/функций и их аргументов (кроме `args` и `kwargs`). Если функция/метод ничего не возвращает, то используется `None`.
- Во всех декораторах используется `functools.wraps`.
"""
from typing import Callable, Any
from functools import wraps


def logging(func: Callable) -> Any:
    """
    Ведёт логирование. Записывает название ф-ции
    и записывает ее название и ошибку в файл
    """

    @wraps(func)
    def wrapped_func(*args, **kwargs):
        print(f'Function name: {func.__name__}\nFunction docs: {func.__doc__}\n')
        try:
            result = func(*args, **kwargs)
            return result
        except Exception as exc:
            with open('function_errors.log', 'a') as file:
                file.write(f'\nFunction name: {func.__name__}, '
                           f'Error name: {exc.__class__.__name__}')
    return wrapped_func


@logging
def raise_error() -> None:
    """Raises TypeError"""
    raise TypeError


raise_error()
